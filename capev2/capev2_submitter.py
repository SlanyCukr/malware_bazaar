import logging
import os
from datetime import datetime
from types import SimpleNamespace
from typing import Callable, List, Tuple
import requests

from classes.database_client import DatabaseClient
from utils.utils import get_db_credentials

API_URL = "http://158.196.22.185:8000/apiv2"
SCRIPT_PATH = os.getcwd()
REPORTS_FOLDER = os.path.join(SCRIPT_PATH, "reports")
FILES_PROCESSED_AT_ONE_TIME = 4

# disable logging of external libraries
logging.getLogger().setLevel(logging.CRITICAL)
LOG = logging.getLogger(__name__)
LOG.setLevel(logging.DEBUG)

# Create a console handler and set its level to debug
handler = logging.StreamHandler()
handler.setLevel(logging.DEBUG)

# Create a formatter and set it to the handler
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

# Add the handler to the logger
LOG.addHandler(handler)


def check_result(func: Callable):
    def wrapper(*args, **kwargs) -> requests.Response:
        response: requests.models.Response = func(*args, **kwargs)

        if response.status_code != 200:
            raise Exception(
                f"""API returned status code {response.status_code}.
                Response: {response.text}.
                This happened when calling {func.__qualname__}."""
            )

        return response

    return wrapper


class CapeV2APISubmitter:
    def __init__(self):
        self._api_url = API_URL
        self._reports_folder = REPORTS_FOLDER

    @check_result
    def submit_file(self, file_to_submit: str) -> requests.Response:
        """
        Submit file to the CAPEv2 API.
        :param file_to_submit: File to submit.
        """
        file = {
            'file': open(file_to_submit, 'rb')
        }

        response = requests.post(f"{self._api_url}/tasks/create/file/", files=file)

        return response

    @check_result
    def get_task_status(self, task_id: int) -> requests.Response:
        """
        Get status of a task.
        :param task_id: ID of the task.
        :return: Response from the API.
        """
        response = requests.get(f"{self._api_url}/tasks/view/{task_id}")

        return response

    @check_result
    def get_task_report(self, task_id: int) -> requests.Response:
        """
        Get report of a task.
        :param task_id: ID of the task.
        :return: Response from the API.
        """
        response = requests.get(f"{self._api_url}/tasks/get/report/{task_id}/json/")

        return response

    @check_result
    def get_tasks_list(self, limit: int, offset: int) -> requests.Response:
        """
        Get list of tasks.
        :param limit: Limit of tasks.
        :param offset: Offset of tasks.
        :return: Response from the API.
        """
        response = requests.get(f"{self._api_url}/tasks/list/{limit}/{offset}")

        return response

    @check_result
    def get_basic_task_search(self, sha256_hash: str):
        """
        Get basic task search.
        :param sha256_hash: SHA256 hash of the file.
        :return: Response from the API.
        """
        response = requests.get(f"{self._api_url}/tasks/search/sha256/{sha256_hash}")

        return response


def submit_not_processed_samples(
        not_processed_samples: List[SimpleNamespace],
        cape_v2_api_submitter: CapeV2APISubmitter) -> Tuple[List[SimpleNamespace], List[SimpleNamespace]]:
    """
    Submit not processed samples to the CAPEv2 API.
        Side effect: updates cape_task_id in each sample in the list.
    :param not_processed_samples: List of not processed samples.
    :param cape_v2_api_submitter: CapeV2APISubmitter object.
    """
    processing_samples = []
    error_samples = []

    for not_processed_sample in not_processed_samples:
        response = cape_v2_api_submitter.submit_file(not_processed_sample.path_to_malware)
        response_dict = response.json()

        # TODO: set flag in database to prevent trying to submit the same file again
        if response_dict["error"]:
            LOG.debug(f"Error submitting file {not_processed_sample.sha256_hash}. error_value: {response_dict['error_value']}")
            error_samples.append(not_processed_sample)
            continue

        task_id = response_dict["data"]["task_ids"][0]

        not_processed_sample.cape_task_id = int(task_id)

        processing_samples.append(not_processed_sample)

        LOG.debug(f"Submitted file {not_processed_sample.sha256_hash}.")

    return processing_samples, error_samples


def handle_samples_in_processing(database_client: DatabaseClient, cape_v2_api_submitter: CapeV2APISubmitter):
    """
    Check if samples in processing are done processing.
        Side effect: updates malware_state, time_processed and path_to_report in each sample in the list.
    :param database_client: DatabaseClient object.
    :param cape_v2_api_submitter: CapeV2APISubmitter object.
    """

    malware_samples_in_processing = database_client.get_malware_samples_in_processing()
    samples_to_be_updated_in_database = []
    for malware_sample_in_processing in malware_samples_in_processing:
        response = cape_v2_api_submitter.get_task_status(malware_sample_in_processing.cape_task_id)
        response_dict = response.json()

        if "data" not in response_dict:
            LOG.warning(f"Task {malware_sample_in_processing.cape_task_id} not found.")

        # if task is not done processing, continue
        completed_on = response_dict["data"]["completed_on"]
        if completed_on is None:
            continue

        LOG.debug(f"Malware sample {malware_sample_in_processing.sha256_hash} is done processing, downloading report.")

        # download report
        response = cape_v2_api_submitter.get_task_report(malware_sample_in_processing.cape_task_id)
        path_to_report = f"{REPORTS_FOLDER}/{malware_sample_in_processing.sha256_hash}.json"
        with open(path_to_report, "w+") as f:
            f.write(response.text)

        # update attributes of local object
        malware_sample_in_processing.malware_state = "processed"
        malware_sample_in_processing.time_processed = datetime.strptime(completed_on, "%Y-%m-%d %H:%M:%S")
        malware_sample_in_processing.path_to_report = path_to_report

        # add to list of samples to be updated in database
        samples_to_be_updated_in_database.append(malware_sample_in_processing)

    database_client.update_malware_samples_after_processing(samples_to_be_updated_in_database)
    LOG.debug(f"Updated {samples_to_be_updated_in_database} samples to processed in database.")


def get_tag_that_needs_processing(tags_for_analysis: List[str], processed_tags_count: List[SimpleNamespace]) -> str:
    """
    Get tag that needs processing.
    :param tags_for_analysis: Tags for analysis.
    :param processed_tags_count: List of processed tags count.
    :return: Tag that needs processing.
    """
    tags_proccesed_count = {tag: 0 for tag in tags_for_analysis}

    for processed_tag_count in processed_tags_count:
        for tag in tags_for_analysis:
            if tag.lower() in processed_tag_count.tag.lower():
                tags_proccesed_count[tag] += processed_tag_count.tag_id_count

    # return tag that has lower than 500 processed samples
    for tag, count in tags_proccesed_count.items():
        if count < 500:
            LOG.debug(f"Tag that needs processing: {tag}")

            return tag


if __name__ == "__main__":
    database_client = DatabaseClient(**get_db_credentials())
    cape_v2_api_submitter = CapeV2APISubmitter()

    tags_for_analysis = ["tesla", "trojan", "stealc", "formbook", "heodo"]
    processed_tags_count = database_client.get_processed_tag_counts(tags_for_analysis)
    LOG.debug(f"Processed tags count: {processed_tags_count}")
    tag_that_needs_processing = get_tag_that_needs_processing(tags_for_analysis, processed_tags_count)

    not_processed_samples = database_client.get_not_processed_malware_sample(FILES_PROCESSED_AT_ONE_TIME, tag_that_needs_processing)
    processing_samples, error_samples = submit_not_processed_samples(not_processed_samples, cape_v2_api_submitter)

    database_client.update_malware_state_to_processing(processing_samples)
    LOG.debug(f"Updated {processing_samples} samples to processing state.")
    database_client.update_malware_state_to_error(error_samples)
    LOG.debug(f"Updated {error_samples} samples to error state.") 

    handle_samples_in_processing(database_client, cape_v2_api_submitter)

    database_client.disconnect()
