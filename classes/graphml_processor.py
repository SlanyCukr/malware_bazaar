import itertools
import logging
import random
import matplotlib.pyplot as plt
from typing import List, Tuple
import networkx as nx

from classes.database_client import DatabaseClient


class GraphMLProcessor:
    def __init__(self, db_client: DatabaseClient, processed_tags: List[str], logger: logging.Logger):
        self._db_client = db_client
        self.processed_tags = processed_tags
        self.tag_graphml_mapping = {}
        self.logger = logger

        # generate random colors for each processed tag
        self.color_map = {tag: self.generate_random_color() for tag in self.processed_tags}

    @staticmethod
    def generate_random_color():
        return "#{:06x}".format(random.randint(0, 0xFFFFFF))

    def set_malware_graphml_paths_for_tags(self):
        """
        Set the malware report paths for the tags.
        """
        self.logger.debug("Setting malware report paths for tags.")

        for tag in self.processed_tags:
            self.logger.debug(f"Finding reports for tag: {tag}")

            tag_like = f"%{tag}%"
            query = f"""
            SELECT
                m.id,
                m.sha256_hash,
                %s AS tag,
                mg.path AS path_to_graphml
            FROM
                visualization.malware_graphml mg
            JOIN 
                malware_bazaar.malware m ON mg.malware_id = m.id
            JOIN
                malware_bazaar.malware_tag mt ON mt.malware_id = mg.malware_id
            JOIN
                malware_bazaar.tag t ON mt.tag_id = t.id AND LOWER(t.tag) LIKE %s
            """
            results = self._db_client.query(query, parameters=(tag, tag_like))

            self.tag_graphml_mapping[tag] = results

    @staticmethod
    def load_and_analyze_graph(file_path: str) -> Tuple[List[int], dict, dict, dict]:
        """
        Load and analyze the graph.
        @param file_path: The path to the graphml file.
        @return: The degree distribution, degree centrality, betweenness centrality, and clustering coefficient.
        """
        # Load the graph
        graph = nx.read_graphml(file_path)

        # Calculate metrics
        degree_centrality = nx.degree_centrality(graph)
        betweenness_centrality = nx.betweenness_centrality(graph)
        clustering_coefficient = nx.clustering(graph)
        degree_distribution = [degree for node, degree in graph.degree()]

        return degree_distribution, degree_centrality, betweenness_centrality, clustering_coefficient

    def plot_metric(self, metric_dict: dict, title: str, file_name: str):
        for tag, metrics in metric_dict.items():
            # Flatten the list if it contains lists of lists
            flat_metrics = list(itertools.chain(*metrics))
            plt.hist(flat_metrics, bins=30, alpha=0.5, label=tag, color=self.color_map[tag])
        plt.title(title)
        plt.xlabel('Value')
        plt.ylabel('Frequency')
        plt.legend()
        plt.savefig(f"{file_name}.png")  # Save the figure as a PNG file
        plt.close()  # Close the plot figure

    def process_graphml_files(self):
        degree_distributions = {tag: [] for tag in self.processed_tags}
        degree_centralities = {tag: [] for tag in self.processed_tags}
        betweenness_centralities = {tag: [] for tag in self.processed_tags}
        clustering_coefficients = {tag: [] for tag in self.processed_tags}

        for tag, database_results in self.tag_graphml_mapping.items():
            paths = [result.path_to_graphml for result in database_results]

            for path in paths:
                results = self.load_and_analyze_graph(path)
                degree_distributions[tag].append(results[0])
                degree_centralities[tag].append(list(results[1].values()))
                betweenness_centralities[tag].append(list(results[2].values()))
                clustering_coefficients[tag].append(list(results[3].values()))

        self.plot_metric(degree_distributions, 'Degree Distribution', "degree_distribution")
        self.plot_metric(degree_centralities, 'Degree Centrality', "degree_centrality")
        self.plot_metric(betweenness_centralities, 'Betweenness Centrality', "betweenness_centrality")
        self.plot_metric(clustering_coefficients, 'Clustering Coefficient', "clustering_coefficient")
