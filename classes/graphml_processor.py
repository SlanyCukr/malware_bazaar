import itertools
import logging
import os

import matplotlib.pyplot as plt
from typing import List, Tuple
import networkx as nx
import numpy as np
import seaborn as sns
from tqdm import tqdm

from classes.database_client import DatabaseClient


class GraphMLProcessor:
    def __init__(self, db_client: DatabaseClient, processed_tags: List[str], logger: logging.Logger):
        self._db_client = db_client
        self.processed_tags = processed_tags
        self.tag_graphml_mapping = {}
        self.logger = logger

        # generate random colors for each processed tag
        colors = self.generate_distinct_colors(len(self.processed_tags))
        self.color_map = {tag: color for tag, color in zip(self.processed_tags, colors)}

    @staticmethod
    def generate_distinct_colors(n):
        palette = sns.color_palette("hsv", n)  # 'hsv' is a good choice for distinct colors
        return palette.as_hex()

    def load_malware_graphml_paths_for_tags(self):
        """
        Set the malware report paths for the tags.
        """
        self.logger.debug("Setting malware report paths for tags.")

        for tag in self.processed_tags:
            self.logger.debug(f"Finding reports for tag: {tag}")

            tag_like = f"%{tag}%"
            query = f"""
            SELECT
                m.id,
                m.sha256_hash,
                %s AS tag,
                mg.path AS path_to_graphml
            FROM
                visualization.malware_graphml mg
            JOIN 
                malware_bazaar.malware m ON mg.malware_id = m.id
            JOIN
                malware_bazaar.malware_tag mt ON mt.malware_id = mg.malware_id
            JOIN
                malware_bazaar.tag t ON mt.tag_id = t.id AND LOWER(t.tag) LIKE %s
            --WHERE m.sha256_hash IN ('b76d7c7450892b61891be2cbcfdb364e7b6f3c39a30ea1a3727d57b5683cd237', 'e33aee583553de9a48fbffd5a545ddce4af362aeb4b44ace89209ca8e94306a4', 'ec13e9d840cb34726ee7f6cd9e932ee72e6657dfb3e15c8fddc0a033dd439da6')
                --WHERE m.id IN (306682, 268412, 173587)
            """
            results = self._db_client.query(query, parameters=(tag, tag_like))

            self.tag_graphml_mapping[tag] = results

        self.logger.debug(f"Tag graphml mapping counts: {[(tag, len(results)) for tag, results in self.tag_graphml_mapping.items()]}")

    def save_malware_id_node_count_mapping(self, malware_id_node_count_mapping: dict):
        """
        Save the mapping by batch UPDATE to table malware_graphml.
        @param malware_id_node_count_mapping: The mapping of malware IDs to node counts.
        """
        query = """
                UPDATE visualization.malware_graphml 
                SET node_count = data.node_count
                FROM (VALUES %s) AS data(node_count, malware_id)
                WHERE malware_graphml.malware_id = data.malware_id
            """

        # Prepare a list of tuples from the dictionary for the batch operation
        update_values = [(node_count, malware_id) for malware_id, node_count in malware_id_node_count_mapping.items()]

        self._db_client.execute_values(sql=query, data=update_values)

    def save_malware_id_svg_path_mapping(self, malware_id_svg_path_mapping: dict):
        """
        Save the mapping by batch UPDATE to table malware_graphml.
        @param malware_id_svg_path_mapping: The mapping of malware IDs to SVG paths.
        """
        query = "INSERT INTO visualization.malware_graph_picture (malware_id, path) VALUES %s ON CONFLICT DO NOTHING"

        # Prepare a list of tuples from the dictionary for the batch operation
        update_values = [(malware_id, svg_path) for malware_id, svg_path in malware_id_svg_path_mapping.items()]

        self._db_client.execute_values(sql=query, data=update_values)

    @staticmethod
    def load_and_analyze_graph(file_path: str) -> Tuple[List[int], dict, dict, dict, float, float]:
        """
        Load and analyze the graph.
        @param file_path: The path to the graphml file.
        @return: The degree distribution, degree centrality, betweenness centrality, and clustering coefficient.
        """
        # Load the graph
        graph = nx.read_graphml(file_path)

        # Calculate metrics
        degree_centrality = nx.degree_centrality(graph)
        betweenness_centrality = nx.betweenness_centrality(graph)
        clustering_coefficient = nx.clustering(graph)
        degree_distribution = [degree for node, degree in graph.degree()]

        # Calculate in-degree and out-degree of 1 portions
        in_degrees = graph.in_degree()
        out_degrees = graph.out_degree()

        total_nodes = max(graph.number_of_nodes(), 1)  # Avoid division by zero

        in_degree_one_count = sum(1 for _, degree in in_degrees if degree == 1)
        out_degree_one_count = sum(1 for _, degree in out_degrees if degree == 1)

        portion_in_degree_one = in_degree_one_count / total_nodes
        portion_out_degree_one = out_degree_one_count / total_nodes

        return degree_distribution, degree_centrality, betweenness_centrality, clustering_coefficient, portion_in_degree_one, portion_out_degree_one

    def plot_metric(self, metric_dict: dict, title: str, file_name: str, x_limit: int = None, y_limit: int = None):
        plt.figure(figsize=(10, 6))
        all_averages = []  # To track all averages for setting y limits
        for tag, metrics in metric_dict.items():
            x_values = []
            averages = []

            for i, metric in enumerate(metrics):
                if metric:
                    average = np.mean(metric)
                    averages.append(average)
                    x_values.append(i)

            if averages:
                plt.scatter(x=x_values, y=averages, alpha=0.5, color=self.color_map[tag], label=tag)
                all_averages.extend(averages)  # Add to all averages
            else:
                self.logger.debug(f"No data available for {tag}, skipping...")

        plt.title(title)
        plt.xlabel('Sample Index')
        plt.ylabel('Average Value')
        plt.legend()

        # Adjust x and y axis limits
        if x_values:
            plt.xlim(min(x_values) - 1000, max(x_values) + 1000)  # Add a little extra space on the x-axis
        if all_averages:
            plt.ylim(min(all_averages) - 0.1, max(all_averages) + 0.1)  # Add a little extra space on the y-axis

        if x_limit:
            plt.xlim(0, x_limit)
        if y_limit:
            plt.ylim(0, y_limit)

        plt.savefig(f"{file_name}.png")
        self.logger.debug(f"Saved plot to: {file_name}.png")
        plt.close()

    def process_graphml_files(self):
        degree_distributions = {tag: [] for tag in self.processed_tags}
        degree_centralities = {tag: [] for tag in self.processed_tags}
        betweenness_centralities = {tag: [] for tag in self.processed_tags}
        clustering_coefficients = {tag: [] for tag in self.processed_tags}
        portion_in_degree_one = {tag: [] for tag in self.processed_tags}
        portion_out_degree_one = {tag: [] for tag in self.processed_tags}

        for tag, database_results in self.tag_graphml_mapping.items():
            paths = [result.path_to_graphml for result in database_results]

            for path in paths:
                results = self.load_and_analyze_graph(path)
                degree_distributions[tag].append(results[0])
                degree_centralities[tag].append(list(results[1].values()))
                betweenness_centralities[tag].append(list(results[2].values()))
                clustering_coefficients[tag].append(list(results[3].values()))
                portion_in_degree_one[tag].append(results[4])
                portion_out_degree_one[tag].append(results[5])

        self.plot_metric(degree_distributions, 'Degree Distribution', "degree_distribution")
        self.plot_metric(degree_centralities, 'Degree Centrality', "degree_centrality")
        self.plot_metric(betweenness_centralities, 'Betweenness Centrality', "betweenness_centrality")
        self.plot_metric(clustering_coefficients, 'Clustering Coefficient', "clustering_coefficient")
        #self.plot_metric(portion_in_degree_one, 'Portion of Nodes with In-degree of 1', "in_degree_one_portion", y_limit=1)

        self.plot_in_out_degrees(portion_in_degree_one, portion_out_degree_one, 'Portion of Nodes with In-degree of 1 and Out-degree of 1', 'in_out_degrees')

    def visualize_graphml_files(self, output_folder: str):
        """
        Generate SVG visualizations for selected graphml files with specific formatting.
        @param output_folder: The directory to save the SVG files.
        """
        # Ensure the output folder exists
        os.makedirs(output_folder, exist_ok=True)

        malware_id_node_count_mapping = {}
        malware_id_svg_path_mapping = {}

        for tag, database_results in self.tag_graphml_mapping.items():
            self.logger.info(f"Visualizing tag: {tag}")
            for result in tqdm(database_results):
                # Load the graph directly here to avoid multiple I/O operations
                graph = nx.read_graphml(result.path_to_graphml)
                num_nodes = graph.number_of_nodes()

                # Store the number of nodes for each malware ID
                malware_id_node_count_mapping[result.id] = num_nodes

                self.generate_svg(graph, result.sha256_hash, output_folder)

                # Store the SVG path for each malware ID
                malware_id_svg_path_mapping[result.id] = os.path.join(output_folder, f"{result.sha256_hash}.svg")

        self.save_malware_id_node_count_mapping(malware_id_node_count_mapping)
        self.save_malware_id_svg_path_mapping(malware_id_svg_path_mapping)

        print(f"Generated visualizations.")

    def plot_in_out_degrees(self, in_degrees, out_degrees, title, file_name):
        plt.figure(figsize=(10, 6))
        for tag in in_degrees:
            plt.scatter(in_degrees[tag], out_degrees[tag], label=tag, alpha=0.5)

        plt.title(title)
        plt.xlabel('Portion of Nodes with In-degree of 1')
        plt.ylabel('Portion of Nodes with Out-degree of 1')
        plt.legend()
        plt.savefig(f"{file_name}.png")
        self.logger.debug(f"Saved plot to: {file_name}.png")
        plt.close()

    def generate_svg(self, graph, sha256_hash, output_folder):
        """
        Generate two SVG files for the graph: one original and one with nodes having in-degree of 1 removed.
        @param graph: The graph to visualize.
        @param sha256_hash: SHA256 hash of the graph used for naming the SVG files.
        @param output_folder: Folder where SVGs are stored.
        """
        plt.figure(figsize=(12, 8))
        pos = nx.circular_layout(graph)
        nx.draw(graph, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=1500, font_size=8,
                arrows=True)

        # Save the original graph SVG
        plt.savefig(os.path.join(output_folder, f"{sha256_hash}.svg"))
        self.logger.debug(f"Saved SVG to: {os.path.join(output_folder, f'{sha256_hash}.svg')}")
        plt.close()

        # Remove nodes with in-degree of 1
        remove_nodes = [node for node, degree in graph.in_degree() if degree == 1]
        #self.logger.debug(f"Removing nodes: {remove_nodes}")
        graph.remove_nodes_from(remove_nodes)

        # Re-draw and save the modified graph
        plt.figure(figsize=(12, 8))
        nx.draw(graph, pos, with_labels=True, node_color='lightgreen', edge_color='gray', node_size=1500, font_size=8,
                arrows=True)
        plt.savefig(os.path.join(output_folder, f"{sha256_hash}_reduced.svg"))
        self.logger.debug(f"Saved SVG to: {os.path.join(output_folder, f'{sha256_hash}_reduced.svg')}")
        plt.close()