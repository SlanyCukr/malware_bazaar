import json
import logging
import os
from typing import List, Tuple
import networkx as nx

from classes.database_client import DatabaseClient


class GraphMLCreator:
    def __init__(self, db_client: DatabaseClient, processed_tags: List[str], logger: logging.Logger):
        self._db_client = db_client
        self.processed_tags = processed_tags
        self.tag_reports_mapping = {}
        self.logger = logger

    def set_malware_report_paths_for_tags(self):
        """
        Set the malware report paths for the tags.
        """
        self.logger.debug("Setting malware report paths for tags.")

        for tag in self.processed_tags:
            self.logger.debug(f"Finding reports for tag: {tag}")

            tag_like = f"%{tag}%"
            query = """
            SELECT
                m.id,
                m.sha256_hash,
                m.path_to_report
            FROM
                malware_bazaar.malware m
            JOIN
                malware_bazaar.malware_tag mt ON mt.malware_id = m.id
            JOIN
                malware_bazaar.tag t ON mt.tag_id = t.id AND LOWER(t.tag) LIKE %s
            WHERE 
                m.malware_state = 'processed' AND 
                NOT EXISTS 
                    (
                        SELECT 1 FROM visualization.malware_graphml mg WHERE mg.malware_id = m.id
                    )
            """
            results = self._db_client.query(query, parameters=(tag_like,))

            self.tag_reports_mapping[tag] = results

    def __batch_insert_graphml_paths(self, graphml_data: List[Tuple[int, str]]):
        """
        Perform a batch insert of graphml paths into the database.
        @param graphml_data: The graphml data to insert.
        """
        insert_query = "INSERT INTO visualization.malware_graphml (malware_id, path) VALUES %s"

        self._db_client.execute_values(insert_query, graphml_data, page_size=100, commit=True)

    def process_tag_reports(self):
        """
        Process the reports for the tags.
        """
        self.logger.debug("Processing tag reports.")

        # Define the base path for saving the GraphML files
        base_path = os.path.join(os.getcwd(), "visualization", "graphml")
        # Ensure the directory exists
        os.makedirs(base_path, exist_ok=True)

        # Initialize a list to store (malware_id, graphml_path) tuples
        graphml_data_for_insert = []

        for tag, reports in self.tag_reports_mapping.items():
            self.logger.debug(f"Processing reports for tag: {tag}")

            for report in reports:
                self.logger.debug(f"Processing report: {report.path_to_report}")
                # Construct the GraphML file path
                report_filename = os.path.basename(report.path_to_report)
                graphml_filename = report_filename.replace('.json', '.graphml')
                graphml_path = os.path.join(base_path, graphml_filename)

                # Load the JSON report
                with open(report.path_to_report, "r") as file:
                    report_json = json.load(file)
                    graph = self.__create_graph_from_report(report_json)

                    # Save the GraphML file to the specified path
                    nx.write_graphml(graph, graphml_path)
                    self.logger.debug(f"GraphML saved to: {graphml_path}")

                # Append (malware_id, graphml_path) tuple to the list
                graphml_data_for_insert.append((report.id, graphml_path))

        # Perform a batch insert of the graphml paths
        self.logger.debug("Performing batch insert of graphml paths.")
        self.__batch_insert_graphml_paths(graphml_data_for_insert)

    @staticmethod
    def __create_graph_from_report(report_json: dict) -> nx.DiGraph:
        """
        Create a directed graph from the report JSON.
        :param report_json: The report JSON.
        :return: The directed graph.
        """
        G = nx.DiGraph()

        for process in report_json.get("behavior", {}).get("processes", []):
            previous_api = None
            first_edge_added = False  # Flag to check if the first edge has been added

            calls = process.get("calls", [])
            for i, call in enumerate(calls):
                api = call["api"]

                # Ensure each API call is represented as a node, without additional attributes for simplicity
                if api not in G:
                    G.add_node(api, label=api, type="api_call")

                # Add or update edges between consecutive API calls
                if previous_api is not None and previous_api != api:
                    if not G.has_edge(previous_api, api):
                        # For the first edge in the sequence, color it differently (e.g., green)
                        if not first_edge_added:
                            G.add_edge(previous_api, api, weight=1, color="green")
                            first_edge_added = True
                        else:
                            G.add_edge(previous_api, api, weight=1,
                                       color="black")  # Default color for intermediate edges
                    else:
                        # Increment the weight if the edge already exists
                        G[previous_api][api]['weight'] += 1

                previous_api = api

                # For the last edge in the sequence, color it differently (e.g., red)
                if i == len(calls) - 2:  # Second to last call, next one is the last, so this is the last edge
                    if previous_api and api and G.has_edge(previous_api, api):
                        G[previous_api][api]['color'] = "red"

        return G
