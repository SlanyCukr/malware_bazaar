import datetime
from types import SimpleNamespace
from typing import Callable, Optional, Union, Tuple, List, Any
import psycopg2
import psycopg2.extras


def check_connection(func: Callable):
    def wrapper(*args, **kwargs):
        # first argument is 'self' when called by object (DatabaseClient)
        connection = args[0]._connection

        if not connection:
            raise RuntimeError(f"Connection is not established or is closed. This happened when calling {func.__qualname__}.")

        func_result = func(*args, **kwargs)

        return func_result

    return wrapper


class DatabaseClient:
    """
    Database client that uses psycopg2 to connect to a PostgreSQL database.
    """
    def __init__(self, host: str, user: str, password: str, port: int = 5432, autocommit: bool = False):
        self._connection = psycopg2.connect(
            host=host,
            user=user,
            password=password,
            port=port,
            database="malware_database"
        )

        self._connection.autocommit = autocommit

    def disconnect(self):
        """
        Close the database connection.
        """
        if self._connection:
            self._connection.close()
            self._connection = None

    def __del__(self):
        """
        Close the connection when this object is deleted.
        """
        self.disconnect()

    @check_connection
    def commit(self):
        """
        Commit pending transactions.
        """
        self._connection.commit()

    @check_connection
    def rollback(self):
        """
        Rolls back any pending transactions.
        """
        self._connection.rollback()

    @check_connection
    def query(self, sql: str, parameters: Optional[Union[Tuple, dict]] = None) -> List[SimpleNamespace]:
        """
        Queries all rows.
        :param sql: SQL to execute.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :return: Table data as a list of :class:`SimpleNamespace` objects.
            (e.q. Get 'id' values of the first row: `result[0].id`)
        """
        with self._connection.cursor() as cursor:
            cursor.execute(sql, parameters)
            result = cursor.fetchall()

            # get column names from the query result
            columns = [desc[0] for desc in cursor.description]

            # for each row create a SimpleNamespace object that has
            # the values in attributes (attribute name = column name)
            return [SimpleNamespace(**dict(zip(columns, row))) for row in result]

    def query_one(self, sql: str, parameters: Optional[Union[Tuple, dict]] = None) -> SimpleNamespace:
        """
        Queries one row.
        :param sql: SQL to execute.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :return: One row as a :class:`SimpleNamespace` object.
        """
        result = self.query(sql=sql, parameters=parameters)

        # TODO: check if only one row is returned - some kind of logging could be useful.

        return result[0]

    @check_connection
    def execute(
            self,
            sql: str,
            commit: bool = True,
            parameters: Optional[Union[Tuple, dict]] = None,
            returning: bool = False
    ) -> Optional[tuple]:
        """
        Executes a command.
        :param sql: SQL to execute.
        :param commit: Whether to commit the transaction after the command.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :param returning: Whether to return the result of the command.
        """
        with self._connection.cursor() as cursor:
            cursor.execute(sql, parameters)

            if commit:
                self.commit()

            if returning:
                return cursor.fetchone()

    @check_connection
    def execute_values(self, sql: str, data: List[tuple], page_size: int = 100, commit: bool = True):
        with self._connection.cursor() as cursor:
            psycopg2.extras.execute_values(
                cur=cursor,
                sql=sql,
                argslist=data,
                template=None,
                page_size=100,
            )

            if commit:
                self.commit()

    def select_timestamp_of_last_malware_from_database(self) -> datetime.datetime:
        """
        Selects the timestamp of last malware in our database.
        :return: Timestamp of last malware in our database :class:`datetime.datetime`.
        """
        query = "SELECT COALESCE(MAX(time_bazaar), '1899-01-01'::timestamp) AS time_bazaar FROM malware_bazaar.malware"

        result = self.query_one(query)

        return result.time_bazaar

    def insert_malware_into_database(self, filtered_malware: List[dict]):
        """
        Inserts malware into the database.
        :param filtered_malware: Filtered list of malware samples.
        """
        # transform list of dicts into list of tuples
        malware_tuples = [(x["sha256_hash"], x["time_bazaar"], x["path_to_malware"]) for x in filtered_malware]

        query = "INSERT INTO malware_bazaar.malware (sha_256_hash, time_bazaar, path_to_malware) VALUES %s"

        self.execute_values(
            sql=query,
            data=malware_tuples,
            page_size=10000
        )

    def select_samples_without_tags_from_database(self) -> List[SimpleNamespace]:
        """
        Selects samples without tags from the database.
        :return: Samples without tags.
        """
        query = """
        SELECT 
            m.id,
            m.sha_256_hash 
        FROM 
            malware_bazaar.malware m
        WHERE 
            NOT EXISTS (SELECT 1 FROM malware_bazaar.malware_tag mt WHERE mt.malware_id = m.id) 
        """

        result = self.query(query)

        return result

    def insert_tags_into_database(self, tags: List[str]):
        """
        Inserts tags into the database.
        :param tags: List of tags.
        """
        query = "INSERT INTO malware_bazaar.tag (tag) VALUES %s"

        self.execute_values(
            sql=query,
            data=[(tag,) for tag in tags],
            page_size=10000
        )

    def insert_tag_mappings_into_database(self, mappings_to_insert: List[tuple]):
        """
        Inserts a tag mapping into the database.
        :param mappings_to_insert: List of tag mappings.
        """
        query = "INSERT INTO malware_bazaar.malware_tag (malware_id, tag_id) VALUES %s"

        self.execute_values(
            sql=query,
            data=mappings_to_insert,
            page_size=10000
        )

    def select_tags_from_database(self) -> List[SimpleNamespace]:
        """
        Selects tags from the database.
        :return: Tags.
        """
        query = "SELECT id, tag FROM malware_bazaar.tag"

        result = self.query(query)

        return result
