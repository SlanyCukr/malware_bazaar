import datetime
from types import SimpleNamespace
from typing import Callable, Optional, Union, Tuple, List, Any
import psycopg2
import psycopg2.extras


def check_connection(func: Callable):
    """
    Checks if the connection is established and not closed.
    :param func: Function to wrap.
    :return: Wrapped function.
    """
    def wrapper(*args, **kwargs):
        # first argument is 'self' when called by object (DatabaseClient)
        connection = args[0]._connection

        if not connection:
            raise RuntimeError(f"Connection is not established or is closed. This happened when calling {func.__qualname__}.")

        func_result = func(*args, **kwargs)

        return func_result

    return wrapper


class DatabaseClient:
    """
    Database client that uses psycopg2 to connect to a PostgreSQL database.
    """
    def __init__(self, host: str, user: str, password: str, port: int = 5432, autocommit: bool = False):
        self._connection = psycopg2.connect(
            host=host,
            user=user,
            password=password,
            port=port,
            database="malware_database"
        )

        self._connection.autocommit = autocommit

    def disconnect(self):
        """
        Close the database connection.
        """
        if self._connection:
            self._connection.close()
            self._connection = None

    def __del__(self):
        """
        Close the connection when this object is deleted.
        """
        self.disconnect()

    @check_connection
    def commit(self):
        """
        Commit pending transactions.
        """
        self._connection.commit()

    @check_connection
    def rollback(self):
        """
        Rolls back any pending transactions.
        """
        self._connection.rollback()

    @check_connection
    def query(self, sql: str, parameters: Optional[Union[Tuple, dict]] = None) -> List[SimpleNamespace]:
        """
        Queries all rows.
        :param sql: SQL to execute.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :return: Table data as a list of :class:`SimpleNamespace` objects.
            (e.q. Get 'id' values of the first row: `result[0].id`)
        """
        with self._connection.cursor() as cursor:
            cursor.execute(sql, parameters)
            result = cursor.fetchall()

            # get column names from the query result
            columns = [desc[0] for desc in cursor.description]

            # for each row create a SimpleNamespace object that has
            # the values in attributes (attribute name = column name)
            return [SimpleNamespace(**dict(zip(columns, row))) for row in result]

    def query_one(self, sql: str, parameters: Optional[Union[Tuple, dict]] = None) -> SimpleNamespace:
        """
        Queries one row.
        :param sql: SQL to execute.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :return: One row as a :class:`SimpleNamespace` object.
        """
        result = self.query(sql=sql, parameters=parameters)

        # TODO: check if only one row is returned - some kind of logging could be useful.

        return result[0]

    @check_connection
    def execute(
            self,
            sql: str,
            commit: bool = True,
            parameters: Optional[Union[Tuple, dict]] = None,
            returning: bool = False
    ) -> Optional[tuple]:
        """
        Executes a command.
        :param sql: SQL to execute.
        :param commit: Whether to commit the transaction after the command.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :param returning: Whether to return the result of the command.
        """
        with self._connection.cursor() as cursor:
            cursor.execute(sql, parameters)

            if commit:
                self.commit()

            if returning:
                return cursor.fetchone()

    @check_connection
    def execute_values(self, sql: str, data: List[tuple], page_size: int = 100, commit: bool = True):
        with self._connection.cursor() as cursor:
            psycopg2.extras.execute_values(
                cur=cursor,
                sql=sql,
                argslist=data,
                template=None,
                page_size=100,
            )

            if commit:
                self.commit()

    def select_timestamp_of_last_malware_from_database(self) -> datetime.datetime:
        """
        Selects the timestamp of last malware in our database.
        :return: Timestamp of last malware in our database :class:`datetime.datetime`.
        """
        query = "SELECT COALESCE(MAX(time_bazaar), '1899-01-01'::timestamp) AS time_bazaar FROM malware_bazaar.malware"

        result = self.query_one(query)

        return result.time_bazaar

    def insert_malware_into_database(self, filtered_malware: List[dict]):
        """
        Inserts malware into the database.
        :param filtered_malware: Filtered list of malware samples.
        """
        # transform list of dicts into list of tuples
        malware_tuples = [(x["sha256_hash"], x["time_bazaar"], x["path_to_malware"]) for x in filtered_malware]

        query = "INSERT INTO malware_bazaar.malware (sha256_hash, time_bazaar, path_to_malware) VALUES %s"

        self.execute_values(
            sql=query,
            data=malware_tuples,
            page_size=10000
        )

    def select_samples_without_tags_from_database(self) -> List[SimpleNamespace]:
        """
        Selects samples without tags from the database.
        :return: Samples without tags.
        """
        query = """
        SELECT 
            m.id,
            m.sha256_hash 
        FROM 
            malware_bazaar.malware m
        WHERE 
            NOT EXISTS (SELECT 1 FROM malware_bazaar.malware_tag mt WHERE mt.malware_id = m.id) 
        """

        result = self.query(query)

        return result

    def insert_tags_into_database(self, tags: List[str]):
        """
        Inserts tags into the database.
        :param tags: List of tags.
        """
        query = "INSERT INTO malware_bazaar.tag (tag) VALUES %s ON CONFLICT DO NOTHING"

        self.execute_values(
            sql=query,
            data=[(tag,) for tag in tags],
            page_size=10000
        )

    def insert_tag_mappings_into_database(self, mappings_to_insert: List[tuple]):
        """
        Inserts a tag mapping into the database.
        :param mappings_to_insert: List of tag mappings.
        """
        query = "INSERT INTO malware_bazaar.malware_tag (malware_id, tag_id) VALUES %s"

        self.execute_values(
            sql=query,
            data=mappings_to_insert,
            page_size=10000
        )

    def select_tags_from_database(self, tags: Optional[List[str]] = None) -> List[SimpleNamespace]:
        """
        Selects tags from the database.
            Can be filtered by a list of tags.
        :param tags: List of tags to select.
        :return: Tags.
        """
        query = "SELECT id, tag FROM malware_bazaar.tag"
        parameters = None
        if tags:
            query = "SELECT id, tag FROM malware_bazaar.tag WHERE tag IN %s"
            parameters = (tuple(tags),)

        result = self.query(query, parameters)

        return result

    def select_samples_filtered_by_hash(self, hashes: List[str]) -> List[SimpleNamespace]:
        """
        Selects samples from the database.
        :return: Samples.
        """
        query = "SELECT id, sha256_hash FROM malware_bazaar.malware WHERE sha256_hash IN %s"
        parameters = (tuple(hashes),)

        result = self.query(query, parameters)

        return result

    def select_last_n_samples_without_virus_total(self, limit: int, focused_tags: List[str]) -> List[SimpleNamespace]:
        """
        Selects last n samples without virus total.
        :param limit: Number of samples to select.
        :param focused_tags: List of tags to focus on.
        :return: Samples.
        """
        query = """
        SELECT 
            m.id,
            m.sha256_hash
        FROM 
            malware_bazaar.malware m 
        WHERE 
            NOT EXISTS 
            (
                SELECT 1 FROM virus_total.api_result vta WHERE vta.malware_id = m.id
            ) 
            AND 
            EXISTS 
                (
                    SELECT 1 FROM malware_bazaar.malware_tag mt WHERE mt.malware_id = m.id AND mt.tag_id IN 
                    (
                        SELECT id FROM malware_bazaar.tag t WHERE t.tag = ANY(%s) 
                    )
                ) 
        ORDER BY m.id DESC
        LIMIT %s
        """
        parameters = (focused_tags, limit)

        result = self.query(query, parameters)

        return result

    def insert_virus_total_analysis_into_database(self, api_results_with_ids: List[tuple]):
        """
        Inserts virus total analysis into the database.
        :param api_results_with_ids: List of virus total analysis with malware IDs.
        """
        query = "INSERT INTO virus_total.api_result (malware_id, result) VALUES %s"

        self.execute_values(
            sql=query,
            data=api_results_with_ids,
            page_size=10000
        )

    def get_not_processed_malware_sample(self, files_processed_at_one_time: int) -> List[SimpleNamespace]:
        """
        Selects a malware sample that has not been processed yet.
        :return: Malware sample.
        """
        query = """
        SELECT 
            m.id,
            m.path_to_malware,
            m.malware_state,
            m.cape_task_id,
            m.sha256_hash
        FROM 
            malware_bazaar.malware m
        WHERE 
            m.malware_state = 'not_processed' AND 
            m.malware_state != 'error'
        LIMIT %s
        """

        results = self.query(query, (files_processed_at_one_time,))

        return results

    def get_malware_samples_in_processing(self) -> List[SimpleNamespace]:
        """
        Selects malware samples that are in processing.
        :return: Malware samples.
        """
        query = """
        SELECT 
            m.id,
            m.path_to_report,
            m.time_processed,
            m.malware_state,
            m.cape_task_id,
            m.sha256_hash
        FROM 
            malware_bazaar.malware m
        WHERE 
            m.malware_state = 'processing'
        """

        results = self.query(query)

        return results

    def update_malware_state_to_processing(self, malware_samples_in_processing: List[SimpleNamespace]):
        """
        Updates malware_state to processing in the database.
        :param malware_samples_in_processing: List of malware samples in processing.
        """
        query = """
        UPDATE malware_bazaar.malware AS m
        SET
            malware_state = 'processing',
            time_processing_start = NOW(),
            cape_task_id = temp.cape_task_id::INTEGER
        FROM (VALUES %s) AS temp(id, cape_task_id)
        WHERE temp.id = m.id;
        """

        tuple_list = [(x.id, x.cape_task_id) for x in malware_samples_in_processing]

        self.execute_values(query, tuple_list)

    def update_malware_state_to_error(self, error_samples: List[SimpleNamespace]):
        """
        Updates malware_state to error in the database.
        :param error_samples: List of malware samples that caused an error.
        """
        query = """
        UPDATE malware_bazaar.malware AS m
        SET
            malware_state = 'error'
        WHERE m.id IN (%s);
        """

        tuple_list = [(x.id,) for x in error_samples]

        self.execute_values(query, tuple_list)

    def update_malware_samples_after_processing(self, samples_to_be_updated_in_database: List[SimpleNamespace]):
        query = """
        UPDATE malware_bazaar.malware AS m
        SET
            malware_state = 'processed',
            time_processed = temp.time_processed::TIMESTAMP,
            cape_task_id = temp.cape_task_id::INTEGER,
            path_to_report = temp.path_to_report::TEXT
        FROM (VALUES %s) AS temp(id, cape_task_id, time_processed, path_to_report)
        WHERE temp.id = m.id;
        """

        tuple_list = [(x.id, x.cape_task_id, x.time_processed, x.path_to_report) for x in samples_to_be_updated_in_database]

        self.execute_values(query, tuple_list)

    def insert_threat_labels(self, threat_labels: List[tuple]):
        query = "INSERT INTO virus_total.threat_label (threat_label) VALUES %s ON CONFLICT DO NOTHING"

        self.execute_values(
            sql=query,
            data=threat_labels,
            page_size=10000
        )

    def insert_threat_categories(self, threat_categories: List[tuple]):
        query = "INSERT INTO virus_total.threat_category (threat_category) VALUES %s ON CONFLICT DO NOTHING"

        self.execute_values(
            sql=query,
            data=threat_categories,
            page_size=10000
        )

    def insert_threat_names(self, threat_names: List[tuple]):
        query = "INSERT INTO virus_total.threat_name (threat_name) VALUES %s ON CONFLICT DO NOTHING"

        self.execute_values(
            sql=query,
            data=threat_names,
            page_size=10000
        )

    def select_threat_labels(self, threat_labels: List[str]) -> List[SimpleNamespace]:
        query = "SELECT id, threat_label FROM virus_total.threat_label WHERE threat_label = ANY(%s)"

        result = self.query(query, (threat_labels,))

        return result

    def select_threat_categories(self, threat_categories: List[str]) -> List[SimpleNamespace]:
        query = "SELECT id, threat_category FROM virus_total.threat_category WHERE threat_category = ANY(%s)"

        result = self.query(query, (threat_categories,))

        return result

    def select_threat_names(self, threat_names: List[str]) -> List[SimpleNamespace]:
        query = "SELECT id, threat_name FROM virus_total.threat_name WHERE threat_name = ANY(%s)"

        result = self.query(query, (threat_names,))

        return result

    def insert_threat_labels_malware_mapping(self, threat_labels_malware_mapping: List[tuple]):
        query = "INSERT INTO virus_total.threat_label_malware (malware_id, threat_label_id) VALUES %s"

        self.execute_values(
            sql=query,
            data=threat_labels_malware_mapping,
            page_size=10000
        )

    def insert_threat_categories_malware_mapping(self, threat_categories_malware_mapping: List[tuple]):
        query = "INSERT INTO virus_total.threat_category_malware (malware_id, threat_category_id) VALUES %s"

        self.execute_values(
            sql=query,
            data=threat_categories_malware_mapping,
            page_size=10000
        )

    def insert_threat_names_malware_mapping(self, threat_names_malware_mapping: List[tuple]):
        query = "INSERT INTO virus_total.threat_name_malware (malware_id, threat_name_id) VALUES %s"

        self.execute_values(
            sql=query,
            data=threat_names_malware_mapping,
            page_size=10000
        )