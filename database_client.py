import datetime
from types import SimpleNamespace
from typing import Callable, Optional, Union, Tuple, List
import psycopg2
import psycopg2.extras


def check_connection(func: Callable):
    def wrapper(*args, **kwargs):
        # first argument is 'self' when called by object (DatabaseClient)
        connection = args[0]._connection

        if not connection:
            raise RuntimeError(f"Connection is not established or is closed. This happened when calling {func.__qualname__}.")

        func_result = func(*args, **kwargs)

        return func_result

    return wrapper


class DatabaseClient:
    """
    Database client that uses psycopg2 to connect to a PostgreSQL database.
    """
    def __init__(self, host: str, user: str, password: str, port: int = 5432, autocommit: bool = False):
        self._connection = psycopg2.connect(
            host=host,
            user=user,
            password=password,
            port=port,
            database="malware_database"
        )

        self._connection.autocommit = autocommit

    def disconnect(self):
        """
        Close the database connection.
        """
        if self._connection:
            self._connection.close()
            self._connection = None

    def __del__(self):
        """
        Close the connection when this object is deleted.
        """
        self.disconnect()

    @check_connection
    def commit(self):
        """
        Commit pending transactions.
        """
        self._connection.commit()

    @check_connection
    def rollback(self):
        """
        Rolls back any pending transactions.
        """
        self._connection.rollback()

    @check_connection
    def query(self, sql: str, parameters: Optional[Union[Tuple, dict]] = None) -> List[SimpleNamespace]:
        """
        Queries all rows.
        :param sql: SQL to execute.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :return: Table data as a list of :class:`SimpleNamespace` objects.
            (e.q. Get 'id' values of the first row: `result[0].id`)
        """
        with self._connection.cursor() as cursor:
            cursor.execute(sql, parameters)
            result = cursor.fetchall()

            # get column names from the query result
            columns = [desc[0] for desc in cursor.description]

            # for each row create a SimpleNamespace object that has
            # the values in attributes (attribute name = column name)
            return [SimpleNamespace(**dict(zip(columns, row))) for row in result]

    def query_one(self, sql: str, parameters: Optional[Union[Tuple, dict]] = None) -> SimpleNamespace:
        """
        Queries one row.
        :param sql: SQL to execute.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        :return: One row as a :class:`SimpleNamespace` object.
        """
        result = self.query(sql=sql, parameters=parameters)

        # TODO: check if only one row is returned - some kind of logging could be useful.

        return result[0]

    @check_connection
    def execute(self, sql: str, commit: bool = True, parameters: Optional[Union[Tuple, dict]] = None):
        """
        Executes a command.
        :param sql: SQL to execute.
        :param commit: Whether to commit the transaction after the command.
        :param parameters: Parameters for SQL, see more here:
            https://www.psycopg.org/docs/sql.html
        """
        with self._connection.cursor() as cursor:
            cursor.execute(sql, parameters)

            if commit:
                self.commit()

    @check_connection
    def execute_values(self, sql: str, data: List[tuple], commit: bool = True):
        with self._connection.cursor() as cursor:
            psycopg2.extras.execute_values(
                cur=cursor,
                sql=sql,
                argslist=data,
                template=None,
                page_size=100,
            )

            if commit:
                self.commit()

    def select_timestamp_of_last_malware_from_database(self) -> datetime.datetime:
        """
        Selects the timestamp of last malware in our database.
        :return: Timestamp of last malware in our database :class:`datetime.datetime`.
        """
        query = "SELECT COALESCE(MAX(time_bazaar), '1899-01-01'::timestamp) AS time_bazaar FROM malware_bazaar.malware"

        result = self.query_one(query)

        return result.time_bazaar

    def insert_malware_into_database(self, filtered_malware: List[dict]):
        """
        Inserts malware into the database.
        :param filtered_malware: Filtered list of malware samples.
        """
        # transform list of dicts into list of tuples
        malware_tuples = [(x["sha256_hash"], x["time_bazaar"], x["path_to_malware"]) for x in filtered_malware]

        query = "INSERT INTO malware_bazaar.malware (sha_256_hash, time_bazaar, path_to_malware) VALUES %s"

        self.execute_values(sql=query, data=malware_tuples)
